'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _updater = require('../updater');

var _updater2 = _interopRequireDefault(_updater);

var _update = require('./plugins/update');

var _update2 = _interopRequireDefault(_update);

var _analytics = require('../analytics');

var _analytics2 = _interopRequireDefault(_analytics);

var _plugins = require('../plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Update extends _cliEngineCommand2.default {

  async run() {
    // on manual run, also log to file
    if (!this.flags.autoupdate) {
      this.out.stdout.logfile = this.out.autoupdatelog;
      this.out.stderr.logfile = this.out.autoupdatelog;
    }
    this.updater = new _updater2.default(this.out);
    if (this.config.updateDisabled) this.out.warn(this.config.updateDisabled);else {
      this.out.action.start(`${this.config.name}: Updating CLI`);
      let channel = this.argv[0] || this.config.channel;
      let manifest = await this.updater.fetchManifest(channel);
      if (this.config.version === manifest.version && channel === this.config.channel) {
        this.out.action.stop(`already on latest version: ${this.config.version}`);
      } else {
        let { yellow, green } = this.out.color;
        this.out.action.start(`${this.config.name}: Updating CLI from ${green(this.config.version)} to ${green(manifest.version)}${channel === 'stable' ? '' : ' (' + yellow(channel) + ')'}`);
        await this.updater.update(manifest);
        this.out.action.stop();
        try {
          await this.updater.autoupdate(true);
          this.out.exit(0);
        } catch (err) {
          this.out.warn(err, 'post-install autoupdate failed');
        }
      }
    }
    await this.updater.fetchVersion(this.config.channel, true);
    let analytics = new _analytics2.default({ out: this.out, config: this.config });
    await analytics.submit();
    await _update2.default.run({ config: this.config, output: this.out });
    await this.logChop();
    await this.generateAutocompleteCommands();
  }

  async logChop() {
    try {
      const logChopper = require('log-chopper').default;
      await logChopper.chop(this.out.errlog);
    } catch (e) {
      this.out.debug(e.message);
    }
  }

  async generateAutocompleteCommands() {
    const flatten = require('lodash.flatten');
    try {
      // TODO: move from cli to client dir if not already present
      // if (!fs.pathExistsSync(path.join(this.config.dataDir, 'client', 'autocomplete', 'bash', 'heroku'))) {
      //   const cli = path.join(this.config.dataDir, 'cli', 'autocomplete')
      //   const client = path.join(this.config.dataDir, 'client', 'autocomplete')
      //   fs.copySync(cli, client)
      // }
      const plugins = await new _plugins2.default(this.out).list();
      const cmds = plugins.map(p => p.commands.filter(c => !c.hidden).map(c => {
        let publicFlags = Object.keys(c.flags).filter(flag => !c.flags[flag].hidden).map(flag => `--${flag}`).join(' ');
        let flags = publicFlags.length ? ` ${publicFlags}` : '';
        let namespace = p.namespace ? `${p.namespace}:` : '';
        return `${namespace}${c.id}${flags}`;
      }));
      const commands = flatten(cmds).join('\n');
      _fsExtra2.default.writeFileSync(_path2.default.join(this.config.dataDir, 'client', 'node_modules', 'cli-engine', 'autocomplete', 'commands'), commands);
    } catch (e) {
      this.out.debug('Error creating autocomplete commands');
      this.out.debug(e.message);
    }
  }
}
exports.default = Update;
Update.topic = 'update';
Update.args = [{ name: 'channel', optional: true }];
Update.flags = {
  autoupdate: _cliEngineCommand.flags.boolean({ hidden: true })
};